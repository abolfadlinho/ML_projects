# -*- coding: utf-8 -*-
"""GoldPricePredictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12mF_ihMijZktkt0mEsDt6wkqCZklQ10T

Installs
"""

!pip install -q kagglehub tensorflow

"""Imports"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, MaxPooling1D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
import kagglehub

"""Fetching dataset"""

# Download the dataset
path = kagglehub.dataset_download("sid321axn/gold-price-prediction-dataset")
df = pd.read_csv(f'{path}/FINAL_USO.csv')

print("\nDataset shape:", df.shape)
print("\nColumns:", df.columns)
chosen_column = 'Open'
df = df[['Date', chosen_column]]
df.head()

"""Preprocessing"""

print(df.columns)

date_col = 'Date'
value_col = chosen_column #choose which column you want to model on from 62 columns of gold price

# Convert Date to datetime and set as index
df[date_col] = pd.to_datetime(df[date_col])
df.set_index(date_col, inplace=True)

# Sort by date just in case
df = df.sort_index()

# Visualize the gold price over time
plt.figure(figsize=(12, 6))
plt.plot(df[value_col], label='Gold Price')
plt.title('Historical Gold Prices')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.show()

# Feature Engineering
window_size = 30  # Number of previous days to use for prediction

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df[[value_col]])

# Create sequences for CNN
def create_sequences(data, window_size):
    X, y = [], []
    for i in range(window_size, len(data)):
        X.append(data[i-window_size:i, 0])
        y.append(data[i, 0])
    return np.array(X), np.array(y)

X, y = create_sequences(scaled_data, window_size)

# Reshape data for CNN (samples, timesteps, features)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Split data into train and test sets (80-20 split)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

print("\nTraining shape:", X_train.shape)
print("Testing shape:", X_test.shape)

# Build CNN Model
model = Sequential([
    Conv1D(filters=64, kernel_size=3, activation='relu', input_shape=(window_size, 1)),
    MaxPooling1D(pool_size=2),
    Dropout(0.2),

    Conv1D(filters=128, kernel_size=3, activation='relu'),
    MaxPooling1D(pool_size=2),
    Dropout(0.2),

    Flatten(),
    Dense(50, activation='relu'),
    Dropout(0.2),
    Dense(1)
])

optimizer = Adam(learning_rate=0.001)
model.compile(optimizer=optimizer, loss='mse', metrics=['mae'])

model.summary()

# Train the model
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=100,
    batch_size=32,
    validation_split=0.1,
    callbacks=[early_stopping],
    verbose=1
)

# Plot training history
plt.figure(figsize=(12, 5))
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
#plt.ylim(0, 1)
plt.show()

# Evaluate the model
train_loss = model.evaluate(X_train, y_train, verbose=0)
test_loss = model.evaluate(X_test, y_test, verbose=0)

print(f"\nTrain Loss: {train_loss[0]:.4f}, Train MAE: {train_loss[1]:.4f}")
print(f"Test Loss: {test_loss[0]:.4f}, Test MAE: {test_loss[1]:.4f}")

# Make predictions
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Inverse transform predictions to original scale
train_predict = scaler.inverse_transform(train_predict)
y_train_actual = scaler.inverse_transform(y_train.reshape(-1, 1))
test_predict = scaler.inverse_transform(test_predict)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

# Calculate RMSE
train_rmse = np.sqrt(mean_squared_error(y_train_actual, train_predict))
test_rmse = np.sqrt(mean_squared_error(y_test_actual, test_predict))
print(f"\nTrain RMSE: {train_rmse:.2f}")
print(f"Test RMSE: {test_rmse:.2f}")

# Corrected plotting code with proper index handling
plt.figure(figsize=(15, 6))

# Calculate the correct positions for plotting
train_end = window_size + len(train_predict)
test_start = train_end + (len(X_test) - len(test_predict))  # Adjust for any potential differences
test_end = test_start + len(test_predict)

# Create plot arrays
train_plot = np.empty_like(scaled_data)
train_plot[:, :] = np.nan
train_plot[window_size:train_end, :] = train_predict

test_plot = np.empty_like(scaled_data)
test_plot[:, :] = np.nan
test_plot[test_start:test_end, :] = test_predict

# Plot everything
plt.plot(scaler.inverse_transform(scaled_data), label='Actual Price')
plt.plot(train_plot, label='Training Prediction', color='orange')
plt.plot(test_plot, label='Testing Prediction', color='green')
plt.title('Gold Price Prediction')
plt.xlabel('Time')
plt.ylabel('Gold Price (USD)')
plt.legend()
plt.show()

"""Future prediction"""

def predict_future(model, data, window_size, future_days):
    future_predictions = []
    current_sequence = data[-window_size:].reshape(1, window_size, 1)

    for _ in range(future_days):
        next_pred = model.predict(current_sequence)[0, 0]
        future_predictions.append(next_pred)
        current_sequence = np.roll(current_sequence, -1, axis=1)
        current_sequence[0, -1, 0] = next_pred

    return scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1))

# Predict next 30 days
future_days = 30
future_prices = predict_future(model, scaled_data, window_size, future_days)

# Create dates for future predictions
last_date = df.index[-1]
future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=future_days)

# Plot future predictions
plt.figure(figsize=(12, 6))
plt.plot(df.index, df[value_col], label='Historical Price')
plt.plot(future_dates, future_prices, 'r-', label='Future Prediction')
plt.title(f'Gold Price Prediction for Next {future_days} Days')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.show()

print("\nFuture Predictions:")
for i in range(future_days):
    print(f"{future_dates[i].strftime('%Y-%m-%d')}: ${future_prices[i][0]:.2f}")